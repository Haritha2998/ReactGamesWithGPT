{"ast":null,"code":"var _jsxFileName = \"/Users/haritha/Desktop/Job/Portfolio/my_portfolio/src/Hangman.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef, useState } from \"react\";\n// export default function Hangman() {\n//     const canvasRef = useRef(null);\n//     const [animationFrame, setAnimationFrame] = useState(null);\n//     const [word, setWord] = useState('');\n//     const [selectedLetters, setSelectedLetters] = useState([]);\n//     const alphabets = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n//     // useEffect(() => {\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n//     //     const radius = canvas.height / 8;\n//     //     const lineWidth = 4;\n//     //     const color = 'white';\n//     //     const lineHeight = 50; // Adjusted to desired line length\n\n//     //     let currentAngle = 0;\n//     //     let currentHeight = 0;\n//     //     let requestIdCircle = null;\n//     //     let requestIdLine = null;\n\n//     //     const drawCircle = () => {\n//     //         ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas for each frame\n//     //         ctx.beginPath();\n//     //         ctx.arc(canvas.width / 4, canvas.height / 4, radius, 0, currentAngle);\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentAngle += 0.1;\n//     //         if (currentAngle > Math.PI * 2) {\n//     //             cancelAnimationFrame(requestIdCircle);\n//     //             requestIdCircle = null;\n//     //             drawLine(); // Start drawing the line after circle animation\n//     //         } else {\n//     //             requestIdCircle = requestAnimationFrame(drawCircle);\n//     //         }\n//     //     };\n\n//     //     const drawLine = () => {\n//     //         ctx.beginPath();\n//     //         ctx.moveTo(canvas.width / 4, canvas.height/4 + radius); // Start at circle's bottom\n//     //         ctx.lineTo(canvas.width / 4, canvas.height/4 + radius + currentHeight);\n\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentHeight += 1;\n//     //         if (currentHeight > lineHeight) {\n//     //             cancelAnimationFrame(requestIdLine);\n//     //             requestIdLine = null;\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/2 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - radius);\n//     //             ctx.stroke();\n//     //         } else {\n//     //             requestIdLine = requestAnimationFrame(drawLine);\n//     //         }\n//     //     };\n\n//     //     drawCircle();\n//     // }, []);\n\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n\n//     //     // Draw hangman here\n\n//     //     const drawHangman = () => {\n//     //       // Clear canvas\n//     //       ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     //       ctx.strokeStyle = 'white';\n//     //       ctx.lineWidth = 2;\n//     //       // Draw hangman parts\n//     //       // You'll need to implement this part based on the game state\n\n//     //       // Example: Draw the gallows\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(50, 350);\n//     //       ctx.lineTo(200, 350);\n//     //       ctx.lineTo(200, 50);\n//     //       ctx.lineTo(150, 50);\n//     //       ctx.lineTo(150, 100);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the head\n//     //       ctx.beginPath();\n//     //       ctx.arc(150, 125, 25, 0, Math.PI * 2);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the body\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 150);\n//     //       ctx.lineTo(150, 250);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the arms\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(100, 200);\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(200, 200);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the legs\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(125, 300);\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(175, 300);\n//     //       ctx.stroke();\n//     //     };\n\n//     //     // Start animation loop\n//     //     const animate = () => {\n//     //       drawHangman();\n//     //       setAnimationFrame(requestAnimationFrame(animate));\n//     //     };\n\n//     //     animate();\n\n//     //     return () => {\n//     //       cancelAnimationFrame(animationFrame);\n//     //     };\n//     //   }, [animationFrame]);\n//     const renderAlphabets = (item, index) => <div key={index}\n//     className=\"alphabet\" onClick = {() => {\n//         if (!selectedLetters.includes(item)) {\n//             setSelectedLetters([...selectedLetters, item]);\n//           }\n\n//     }}  > \n//        <p style={{\n//         color: selectedLetters.includes(item) ? 'red' : 'grey',\n//         textDecoration: !word.includes(item) ? 'line-through' : 'none',\n//       }}> {item} </p> \n//     </div>\n//     return (\n//         <div className='viewContainer'>\n//             <div className='headerContainer' >\n\n//                 <h2 className='header'>Hangman</h2>\n//             </div>\n//             {/* <canvas ref={canvasRef} width={200} height={200}/>; */}\n//             <div className=\"container\">\n//             <div className=\"alphabetContainer\">\n//                 {alphabets.map((item, index) => renderAlphabets(item, index))}\n//             </div>\n//             </div>\n//         </div>\n//     )\n// }\n\nimport React, { useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Hangman = () => {\n  _s();\n  const [selectedLetters, setSelectedLetters] = useState([]);\n  const alphabets = Array.from({\n    length: 26\n  }, (_, index) => String.fromCharCode('A'.charCodeAt(0) + index));\n  const renderAlphabets = (item, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"alphabet\",\n    onClick: () => handleAlphabetClick(item),\n    style: {\n      color: selectedLetters.includes(item) ? 'red' : 'black',\n      textDecoration: !selectedLetters.includes(item) ? 'none' : 'underline'\n    },\n    children: item\n  }, index, false, {\n    fileName: _jsxFileName,\n    lineNumber: 181,\n    columnNumber: 9\n  }, this);\n  const handleAlphabetClick = item => {\n    if (!selectedLetters.includes(item)) {\n      setSelectedLetters([...selectedLetters, item]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"parent-container\",\n    children: /*#__PURE__*/_jsxDEV(\"h2\", {\n      className: \"header\",\n      children: \"Hangman\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 202,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 201,\n    columnNumber: 9\n  }, this);\n};\n_s(Hangman, \"pwpQV5nJfJTZUFaA9LwFD2RNxb0=\");\n_c = Hangman;\nexport default Hangman;\nvar _c;\n$RefreshReg$(_c, \"Hangman\");","map":{"version":3,"names":["React","useState","jsxDEV","_jsxDEV","Hangman","_s","selectedLetters","setSelectedLetters","alphabets","Array","from","length","_","index","String","fromCharCode","charCodeAt","renderAlphabets","item","className","onClick","handleAlphabetClick","style","color","includes","textDecoration","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/haritha/Desktop/Job/Portfolio/my_portfolio/src/Hangman.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\n// export default function Hangman() {\n//     const canvasRef = useRef(null);\n//     const [animationFrame, setAnimationFrame] = useState(null);\n//     const [word, setWord] = useState('');\n//     const [selectedLetters, setSelectedLetters] = useState([]);\n//     const alphabets = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n//     // useEffect(() => {\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n//     //     const radius = canvas.height / 8;\n//     //     const lineWidth = 4;\n//     //     const color = 'white';\n//     //     const lineHeight = 50; // Adjusted to desired line length\n\n//     //     let currentAngle = 0;\n//     //     let currentHeight = 0;\n//     //     let requestIdCircle = null;\n//     //     let requestIdLine = null;\n\n//     //     const drawCircle = () => {\n//     //         ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas for each frame\n//     //         ctx.beginPath();\n//     //         ctx.arc(canvas.width / 4, canvas.height / 4, radius, 0, currentAngle);\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentAngle += 0.1;\n//     //         if (currentAngle > Math.PI * 2) {\n//     //             cancelAnimationFrame(requestIdCircle);\n//     //             requestIdCircle = null;\n//     //             drawLine(); // Start drawing the line after circle animation\n//     //         } else {\n//     //             requestIdCircle = requestAnimationFrame(drawCircle);\n//     //         }\n//     //     };\n\n//     //     const drawLine = () => {\n//     //         ctx.beginPath();\n//     //         ctx.moveTo(canvas.width / 4, canvas.height/4 + radius); // Start at circle's bottom\n//     //         ctx.lineTo(canvas.width / 4, canvas.height/4 + radius + currentHeight);\n\n\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentHeight += 1;\n//     //         if (currentHeight > lineHeight) {\n//     //             cancelAnimationFrame(requestIdLine);\n//     //             requestIdLine = null;\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/2 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - radius);\n//     //             ctx.stroke();\n//     //         } else {\n//     //             requestIdLine = requestAnimationFrame(drawLine);\n//     //         }\n//     //     };\n\n//     //     drawCircle();\n//     // }, []);\n\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n\n//     //     // Draw hangman here\n\n//     //     const drawHangman = () => {\n//     //       // Clear canvas\n//     //       ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     //       ctx.strokeStyle = 'white';\n//     //       ctx.lineWidth = 2;\n//     //       // Draw hangman parts\n//     //       // You'll need to implement this part based on the game state\n\n//     //       // Example: Draw the gallows\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(50, 350);\n//     //       ctx.lineTo(200, 350);\n//     //       ctx.lineTo(200, 50);\n//     //       ctx.lineTo(150, 50);\n//     //       ctx.lineTo(150, 100);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the head\n//     //       ctx.beginPath();\n//     //       ctx.arc(150, 125, 25, 0, Math.PI * 2);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the body\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 150);\n//     //       ctx.lineTo(150, 250);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the arms\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(100, 200);\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(200, 200);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the legs\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(125, 300);\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(175, 300);\n//     //       ctx.stroke();\n//     //     };\n\n//     //     // Start animation loop\n//     //     const animate = () => {\n//     //       drawHangman();\n//     //       setAnimationFrame(requestAnimationFrame(animate));\n//     //     };\n\n//     //     animate();\n\n//     //     return () => {\n//     //       cancelAnimationFrame(animationFrame);\n//     //     };\n//     //   }, [animationFrame]);\n//     const renderAlphabets = (item, index) => <div key={index}\n//     className=\"alphabet\" onClick = {() => {\n//         if (!selectedLetters.includes(item)) {\n//             setSelectedLetters([...selectedLetters, item]);\n//           }\n\n//     }}  > \n//        <p style={{\n//         color: selectedLetters.includes(item) ? 'red' : 'grey',\n//         textDecoration: !word.includes(item) ? 'line-through' : 'none',\n//       }}> {item} </p> \n//     </div>\n//     return (\n//         <div className='viewContainer'>\n//             <div className='headerContainer' >\n\n//                 <h2 className='header'>Hangman</h2>\n//             </div>\n//             {/* <canvas ref={canvasRef} width={200} height={200}/>; */}\n//             <div className=\"container\">\n//             <div className=\"alphabetContainer\">\n//                 {alphabets.map((item, index) => renderAlphabets(item, index))}\n//             </div>\n//             </div>\n//         </div>\n//     )\n// }\n\nimport React, { useState } from 'react';\n\nconst Hangman = () => {\n    const [selectedLetters, setSelectedLetters] = useState([]);\n    const alphabets = Array.from({ length: 26 }, (_, index) => String.fromCharCode('A'.charCodeAt(0) + index));\n\n    const renderAlphabets = (item, index) => (\n        <div\n            key={index}\n            className=\"alphabet\"\n            onClick={() => handleAlphabetClick(item)}\n            style={{\n                color: selectedLetters.includes(item) ? 'red' : 'black',\n                textDecoration: !selectedLetters.includes(item) ? 'none' : 'underline',\n            }}\n        >\n            {item}\n        </div>\n    );\n\n    const handleAlphabetClick = (item) => {\n        if (!selectedLetters.includes(item)) {\n            setSelectedLetters([...selectedLetters, item]);\n        }\n    };\n\n    return (\n        <div className='parent-container'>\n            <h2 className='header'>Hangman</h2>\n            {/* <div className='container'>\n            <h4 className='header'>Hangman game</h4>\n            </div> */}\n        </div>\n\n    );\n};\n\nexport default Hangman;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAExC,MAAMC,OAAO,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAClB,MAAM,CAACC,eAAe,EAAEC,kBAAkB,CAAC,GAAGN,QAAQ,CAAC,EAAE,CAAC;EAC1D,MAAMO,SAAS,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAG,CAAC,EAAE,CAACC,CAAC,EAAEC,KAAK,KAAKC,MAAM,CAACC,YAAY,CAAC,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,GAAGH,KAAK,CAAC,CAAC;EAE1G,MAAMI,eAAe,GAAGA,CAACC,IAAI,EAAEL,KAAK,kBAChCV,OAAA;IAEIgB,SAAS,EAAC,UAAU;IACpBC,OAAO,EAAEA,CAAA,KAAMC,mBAAmB,CAACH,IAAI,CAAE;IACzCI,KAAK,EAAE;MACHC,KAAK,EAAEjB,eAAe,CAACkB,QAAQ,CAACN,IAAI,CAAC,GAAG,KAAK,GAAG,OAAO;MACvDO,cAAc,EAAE,CAACnB,eAAe,CAACkB,QAAQ,CAACN,IAAI,CAAC,GAAG,MAAM,GAAG;IAC/D,CAAE;IAAAQ,QAAA,EAEDR;EAAI,GARAL,KAAK;IAAAc,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAST,CACR;EAED,MAAMT,mBAAmB,GAAIH,IAAI,IAAK;IAClC,IAAI,CAACZ,eAAe,CAACkB,QAAQ,CAACN,IAAI,CAAC,EAAE;MACjCX,kBAAkB,CAAC,CAAC,GAAGD,eAAe,EAAEY,IAAI,CAAC,CAAC;IAClD;EACJ,CAAC;EAED,oBACIf,OAAA;IAAKgB,SAAS,EAAC,kBAAkB;IAAAO,QAAA,eAC7BvB,OAAA;MAAIgB,SAAS,EAAC,QAAQ;MAAAO,QAAA,EAAC;IAAO;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAIlC,CAAC;AAGd,CAAC;AAACzB,EAAA,CAjCID,OAAO;AAAA2B,EAAA,GAAP3B,OAAO;AAmCb,eAAeA,OAAO;AAAC,IAAA2B,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}