{"ast":null,"code":"// import React, { useEffect, useRef, useState } from \"react\";\n// export default function Hangman() {\n//     const canvasRef = useRef(null);\n//     const [animationFrame, setAnimationFrame] = useState(null);\n//     const [word, setWord] = useState('');\n//     const [selectedLetters, setSelectedLetters] = useState([]);\n//     const alphabets = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n//     // useEffect(() => {\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n//     //     const radius = canvas.height / 8;\n//     //     const lineWidth = 4;\n//     //     const color = 'white';\n//     //     const lineHeight = 50; // Adjusted to desired line length\n\n//     //     let currentAngle = 0;\n//     //     let currentHeight = 0;\n//     //     let requestIdCircle = null;\n//     //     let requestIdLine = null;\n\n//     //     const drawCircle = () => {\n//     //         ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas for each frame\n//     //         ctx.beginPath();\n//     //         ctx.arc(canvas.width / 4, canvas.height / 4, radius, 0, currentAngle);\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentAngle += 0.1;\n//     //         if (currentAngle > Math.PI * 2) {\n//     //             cancelAnimationFrame(requestIdCircle);\n//     //             requestIdCircle = null;\n//     //             drawLine(); // Start drawing the line after circle animation\n//     //         } else {\n//     //             requestIdCircle = requestAnimationFrame(drawCircle);\n//     //         }\n//     //     };\n\n//     //     const drawLine = () => {\n//     //         ctx.beginPath();\n//     //         ctx.moveTo(canvas.width / 4, canvas.height/4 + radius); // Start at circle's bottom\n//     //         ctx.lineTo(canvas.width / 4, canvas.height/4 + radius + currentHeight);\n\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentHeight += 1;\n//     //         if (currentHeight > lineHeight) {\n//     //             cancelAnimationFrame(requestIdLine);\n//     //             requestIdLine = null;\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/2 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - radius);\n//     //             ctx.stroke();\n//     //         } else {\n//     //             requestIdLine = requestAnimationFrame(drawLine);\n//     //         }\n//     //     };\n\n//     //     drawCircle();\n//     // }, []);\n\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n\n//     //     // Draw hangman here\n\n//     //     const drawHangman = () => {\n//     //       // Clear canvas\n//     //       ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     //       ctx.strokeStyle = 'white';\n//     //       ctx.lineWidth = 2;\n//     //       // Draw hangman parts\n//     //       // You'll need to implement this part based on the game state\n\n//     //       // Example: Draw the gallows\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(50, 350);\n//     //       ctx.lineTo(200, 350);\n//     //       ctx.lineTo(200, 50);\n//     //       ctx.lineTo(150, 50);\n//     //       ctx.lineTo(150, 100);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the head\n//     //       ctx.beginPath();\n//     //       ctx.arc(150, 125, 25, 0, Math.PI * 2);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the body\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 150);\n//     //       ctx.lineTo(150, 250);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the arms\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(100, 200);\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(200, 200);\n//     //       ctx.stroke();\n\n//     //       // Example: Draw the legs\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(125, 300);\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(175, 300);\n//     //       ctx.stroke();\n//     //     };\n\n//     //     // Start animation loop\n//     //     const animate = () => {\n//     //       drawHangman();\n//     //       setAnimationFrame(requestAnimationFrame(animate));\n//     //     };\n\n//     //     animate();\n\n//     //     return () => {\n//     //       cancelAnimationFrame(animationFrame);\n//     //     };\n//     //   }, [animationFrame]);\n//     const renderAlphabets = (item, index) => <div key={index}\n//     className=\"alphabet\" onClick = {() => {\n//         if (!selectedLetters.includes(item)) {\n//             setSelectedLetters([...selectedLetters, item]);\n//           }\n\n//     }}  > \n//        <p style={{\n//         color: selectedLetters.includes(item) ? 'red' : 'grey',\n//         textDecoration: !word.includes(item) ? 'line-through' : 'none',\n//       }}> {item} </p> \n//     </div>\n//     return (\n//         <div className='viewContainer'>\n//             <div className='headerContainer' >\n\n//                 <h2 className='header'>Hangman</h2>\n//             </div>\n//             {/* <canvas ref={canvasRef} width={200} height={200}/>; */}\n//             <div className=\"container\">\n//             <div className=\"alphabetContainer\">\n//                 {alphabets.map((item, index) => renderAlphabets(item, index))}\n//             </div>\n//             </div>\n//         </div>\n//     )\n// }","map":{"version":3,"names":[],"sources":["/Users/haritha/Desktop/Job/Portfolio/my_portfolio/src/Hangman.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\n// export default function Hangman() {\n//     const canvasRef = useRef(null);\n//     const [animationFrame, setAnimationFrame] = useState(null);\n//     const [word, setWord] = useState('');\n//     const [selectedLetters, setSelectedLetters] = useState([]);\n//     const alphabets = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n//     // useEffect(() => {\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n//     //     const radius = canvas.height / 8;\n//     //     const lineWidth = 4;\n//     //     const color = 'white';\n//     //     const lineHeight = 50; // Adjusted to desired line length\n\n//     //     let currentAngle = 0;\n//     //     let currentHeight = 0;\n//     //     let requestIdCircle = null;\n//     //     let requestIdLine = null;\n\n//     //     const drawCircle = () => {\n//     //         ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas for each frame\n//     //         ctx.beginPath();\n//     //         ctx.arc(canvas.width / 4, canvas.height / 4, radius, 0, currentAngle);\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentAngle += 0.1;\n//     //         if (currentAngle > Math.PI * 2) {\n//     //             cancelAnimationFrame(requestIdCircle);\n//     //             requestIdCircle = null;\n//     //             drawLine(); // Start drawing the line after circle animation\n//     //         } else {\n//     //             requestIdCircle = requestAnimationFrame(drawCircle);\n//     //         }\n//     //     };\n\n//     //     const drawLine = () => {\n//     //         ctx.beginPath();\n//     //         ctx.moveTo(canvas.width / 4, canvas.height/4 + radius); // Start at circle's bottom\n//     //         ctx.lineTo(canvas.width / 4, canvas.height/4 + radius + currentHeight);\n\n\n//     //         ctx.lineWidth = lineWidth;\n//     //         ctx.strokeStyle = color;\n//     //         ctx.stroke();\n\n//     //         currentHeight += 1;\n//     //         if (currentHeight > lineHeight) {\n//     //             cancelAnimationFrame(requestIdLine);\n//     //             requestIdLine = null;\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/4 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.width / 4 + radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 + 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4, canvas.height/2 + radius);\n//     //             ctx.lineTo(canvas.width / 4 - 2*radius, canvas.height/2 + 2*radius);\n//     //             ctx.stroke();\n//     //             ctx.beginPath();\n//     //             ctx.moveTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/2 + 2*radius);\n//     //             ctx.lineTo(canvas.width / 4 + 3*radius, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - 3*radius);\n//     //             ctx.lineTo(canvas.width / 4, canvas.height/4 - radius);\n//     //             ctx.stroke();\n//     //         } else {\n//     //             requestIdLine = requestAnimationFrame(drawLine);\n//     //         }\n//     //     };\n\n//     //     drawCircle();\n//     // }, []);\n\n//     //     const canvas = canvasRef.current;\n//     //     const ctx = canvas.getContext('2d');\n      \n//     //     // Draw hangman here\n      \n//     //     const drawHangman = () => {\n//     //       // Clear canvas\n//     //       ctx.clearRect(0, 0, canvas.width, canvas.height);\n//     //       ctx.strokeStyle = 'white';\n//     //       ctx.lineWidth = 2;\n//     //       // Draw hangman parts\n//     //       // You'll need to implement this part based on the game state\n      \n//     //       // Example: Draw the gallows\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(50, 350);\n//     //       ctx.lineTo(200, 350);\n//     //       ctx.lineTo(200, 50);\n//     //       ctx.lineTo(150, 50);\n//     //       ctx.lineTo(150, 100);\n//     //       ctx.stroke();\n      \n//     //       // Example: Draw the head\n//     //       ctx.beginPath();\n//     //       ctx.arc(150, 125, 25, 0, Math.PI * 2);\n//     //       ctx.stroke();\n      \n//     //       // Example: Draw the body\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 150);\n//     //       ctx.lineTo(150, 250);\n//     //       ctx.stroke();\n      \n//     //       // Example: Draw the arms\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(100, 200);\n//     //       ctx.moveTo(150, 175);\n//     //       ctx.lineTo(200, 200);\n//     //       ctx.stroke();\n      \n//     //       // Example: Draw the legs\n//     //       ctx.beginPath();\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(125, 300);\n//     //       ctx.moveTo(150, 250);\n//     //       ctx.lineTo(175, 300);\n//     //       ctx.stroke();\n//     //     };\n      \n//     //     // Start animation loop\n//     //     const animate = () => {\n//     //       drawHangman();\n//     //       setAnimationFrame(requestAnimationFrame(animate));\n//     //     };\n      \n//     //     animate();\n      \n//     //     return () => {\n//     //       cancelAnimationFrame(animationFrame);\n//     //     };\n//     //   }, [animationFrame]);\n//     const renderAlphabets = (item, index) => <div key={index}\n//     className=\"alphabet\" onClick = {() => {\n//         if (!selectedLetters.includes(item)) {\n//             setSelectedLetters([...selectedLetters, item]);\n//           }\n        \n//     }}  > \n//        <p style={{\n//         color: selectedLetters.includes(item) ? 'red' : 'grey',\n//         textDecoration: !word.includes(item) ? 'line-through' : 'none',\n//       }}> {item} </p> \n//     </div>\n//     return (\n//         <div className='viewContainer'>\n//             <div className='headerContainer' >\n\n//                 <h2 className='header'>Hangman</h2>\n//             </div>\n//             {/* <canvas ref={canvasRef} width={200} height={200}/>; */}\n//             <div className=\"container\">\n//             <div className=\"alphabetContainer\">\n//                 {alphabets.map((item, index) => renderAlphabets(item, index))}\n//             </div>\n//             </div>\n//         </div>\n//     )\n// }"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}